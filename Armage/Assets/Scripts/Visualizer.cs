//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
namespace Armage
{
	public class Visualizer
	{
		public Visualizer () {
		}

		public static void VisualizeHeightMap(float[,] origMap, float[,] newMap) {
			if (origMap.GetLength (0) != 512 || origMap.Length != newMap.Length) {
				Debug.LogError("Length mismatch, or size doesn't equal 512.");
				return;
			}

			GameObject go = new GameObject();
			go.name = "Visualizer";
			// You can change that line to provide another MeshFilter
			MeshFilter filter = go.AddComponent<MeshFilter>();
			Mesh mesh = filter.mesh;
			mesh.Clear();
			
			float length = 1f;
			float width = 1f;
			int resX = 128; // 2 minimum
			int resZ = 128;
			
			#region Vertices		
			Vector3[] vertices = new Vector3[ resX * resZ ];
			Texture2D tex = new Texture2D(resX, resZ, TextureFormat.ARGB32, false);
			int map1Xlen = newMap.GetLength (0);
			int map1Zlen = newMap.GetLength (1);
			int map2Xlen = origMap.GetLength (0);
			int map2Zlen = origMap.GetLength (1);
			for(int z = 0; z < resZ; z++)
			{
				// [ -length / 2, length / 2 ]
				float zPos = ((float)z / (resZ - 1) - .5f) * length;
				for(int x = 0; x < resX; x++)
				{
					// [ -width / 2, width / 2 ]
					float xPos = ((float)x / (resX - 1) - .5f) * width;

					vertices[ x + z * resX ] = new Vector3( xPos, 0f, zPos );

					float newHeight = newMap[Mathf.RoundToInt (x * map1Xlen / resX), Mathf.RoundToInt (z * map1Zlen / resZ)];
					float origHeight = origMap[Mathf.RoundToInt (x * map2Xlen / resX), Mathf.RoundToInt (z * map2Zlen / resZ)];
					float heightDiff = (newHeight - origHeight);
					float wholeDiff = Mathf.Floor (heightDiff);
					heightDiff -= wholeDiff;

					float r = newHeight < origHeight ? 0 : (wholeDiff > 0 ? heightDiff : 0);
					float g = newHeight < origHeight ? 0 : heightDiff;
					float b = heightDiff;
					Color color = new Color(r, g, b, 1f);
					tex.SetPixel (x, z, color);
				}
			}
			tex.Apply ();
			#endregion
			
			#region Normales
			Vector3[] normales = new Vector3[ vertices.Length ];
			for( int n = 0; n < normales.Length; n++ )
				normales[n] = Vector3.up;
			#endregion
			
			#region UVs		
			Vector2[] uvs = new Vector2[ vertices.Length ];
			for(int v = 0; v < resZ; v++)
			{
				for(int u = 0; u < resX; u++)
				{
					uvs[ u + v * resX ] = new Vector2( (float)u / (resX - 1), (float)v / (resZ - 1) );
				}
			}
			#endregion
			
			#region Triangles
			int nbFaces = (resX - 1) * (resZ - 1);
			int[] triangles = new int[ nbFaces * 6 ];
			int t = 0;
			for(int face = 0; face < nbFaces; face++ )
			{
				// Retrieve lower left corner from face ind
				int i = face % (resX - 1) + (face / (resZ - 1) * resX);
				
				triangles[t++] = i + resX;
				triangles[t++] = i + 1;
				triangles[t++] = i;
				
				triangles[t++] = i + resX;	
				triangles[t++] = i + resX + 1;
				triangles[t++] = i + 1; 
			}
			#endregion
			
			mesh.vertices = vertices;
			mesh.normals = normales;
			mesh.uv = uvs;
			mesh.triangles = triangles;
			
			mesh.RecalculateBounds();
			mesh.Optimize();

			Visualizer.ApplyDiffuse(go, tex);

			go.transform.Translate (new Vector3(0, 20f, 0f));
			go.transform.Rotate (new Vector3(270, 0, 0));
			go.transform.localScale = new Vector3(10f, 10f, 10f);
		}

		public static void ApplyDiffuse(GameObject gameObject, Texture2D mainTex) {
			MeshRenderer renderer = gameObject.GetComponent<MeshRenderer>();
			if (!renderer) {
				renderer = gameObject.AddComponent<MeshRenderer>();
			}
			
			renderer.material = (Material) GameObject.Instantiate (Resources.Load<Material> ("Materials/Terrain/Diffuse"));
			renderer.material.mainTexture = mainTex;
		}
	}
}

