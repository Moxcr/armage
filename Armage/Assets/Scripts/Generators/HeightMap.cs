//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
namespace Armage
{
	public class HeightMap
	{
		public float[,] Heights { get; set; }
		public int Size { get; set; }

		private PerlinGenerator Perlin { get; set; }
		
		public HeightMap(int size, int seed)
		{
			Size = size;
			Heights = new float[Size, Size];
			Perlin = new PerlinGenerator(seed);
		}

		public Color[] ConvertToGrayscaleMap() {
			Color[] colors = new Color[Heights.Length];
			int lenX = Heights.GetLength (0);
			int lenY = Heights.GetLength (1);
			for (int y = 0; y < lenX; y++) {
				for (int x = 0; x < lenY; x++) {
					float color = Heights[x, y] + 0.5f;
					colors[y * lenX + x] = new Color(color, color, color);
				}
			}

			return colors;
		}

		public void AddPerlinNoise(float f)
		{
			for (int i = 0; i < Size; i++)
			{
				for (int j = 0; j < Size; j++)
				{
					Heights[i, j] += Perlin.Noise(f * i / (float)Size, f * j / (float)Size, 0);
				}
			}
		}

		public void Perturb(float f, float d)
		{
			int u, v;
			float[,] temp = new float[Size, Size];
			for (int i = 0; i < Size; ++i)
			{
				for (int j = 0; j < Size; ++j)
				{
					u = i + (int)(Perlin.Noise(f * i / (float)Size, f * j / (float)Size, 0) * d);
					v = j + (int)(Perlin.Noise(f * i / (float)Size, f * j / (float)Size, 1) * d);
					if (u < 0) u = 0; if (u >= Size) u = Size - 1;
					if (v < 0) v = 0; if (v >= Size) v = Size - 1;
					temp[i, j] = Heights[u, v];
				}
			}
			Heights = temp;
		}

		public void Erode(float smoothness)
		{
			for (int i = 1; i < Size - 1; i++)
			{
				for (int j = 1; j < Size - 1; j++)
				{
					float d_max = 0.0f;
					int[] match = { 0, 0 };
					
					for (int u = -1; u <= 1; u++)
					{
						for (int v = -1; v <= 1; v++)
						{
							if(Math.Abs(u) + Math.Abs(v) > 0)
							{
								float d_i = Heights[i, j] - Heights[i + u, j + v];
								if (d_i > d_max)
								{
									d_max = d_i;
									match[0] = u; match[1] = v;
								}
							}
						}
					}
					
					if(0 < d_max && d_max <= (smoothness / (float)Size))
					{
						float d_h = 0.5f * d_max;
						Heights[i, j] -= d_h;
						Heights[i + match[0], j + match[1]] += d_h;
					}
				}
			}
		}

		public void Smoothen()
		{
			for (int i = 1; i < Size - 1; ++i)
			{
				for (int j = 1; j < Size - 1; ++j)
				{
					float total = 0.0f;
					for (int u = -1; u <= 1; u++)
					{
						for (int v = -1; v <= 1; v++)
						{
							total += Heights[i + u, j + v];
						}
					}
					
					Heights[i, j] = total / 9.0f;
				}
			}
		}

		public void Blend(HeightMap subMap, string blendMode, int x, int y, float amount) {
			int diam = subMap.Size;
			float rad = diam / 2;
			int heightsXLen = Heights.GetLength (0);
			int heightsYLen = Heights.GetLength (1);

			for (int i = 0; i < diam; ++i)
			{
				for (int j = 0; j < diam; ++j)
				{
					int origX = (int) (x + (i - rad));
					int origY = (int) (y + (j - rad));
					//Check if point falls within a circle
					double diffXSq = Math.Pow((double) (x - origX), 2.0);
					double diffYSq = Math.Pow((double) (y - origY), 2.0);
					double radSq = Math.Pow ((double) rad, 2.0);

					int actualX = GetSeamlessPoint(heightsXLen, origX);
					int actualY = GetSeamlessPoint(heightsYLen, origY);

					if (diffXSq + diffYSq <= radSq) {

						//if (actualX < heightsXLen && actualY < heightsYLen && actualX >= 0 && actualY >= 0) {
							switch (blendMode) {
								case "add":
								Heights[actualX, actualY] += (1f + Math.Abs (subMap.Heights[i, j])) * amount;
									break;
								case "subtract":
								Heights[actualX, actualY] -= Math.Abs (subMap.Heights[i, j]) * amount;
									break;
							}

							if (Heights[actualX, actualY] <= 0.0f) {
								Heights[actualX, actualY] = 0.001f;
							} else if (Heights[actualX, actualY] > 5.0f) {
								Heights[actualX, actualY] = 5.0f;
							}
						//}
					}
				}
			}
		}

		public void BlurPoint(int x, int y, int amount) {
			float rad = amount / 2;
			float rootAmt = Heights[x, y];
			int heightsX = Heights.GetLength (0);
			int heightsY = Heights.GetLength (1);
			for (int step = 1; step < rad; step++) {
				for (int offPtX = -step; offPtX <= step; offPtX++) {
					int actX = GetSeamlessPoint(heightsX, x + offPtX);
					for (int offPtY = -step; offPtY <= step; offPtY++) {
						int actY = GetSeamlessPoint(heightsY, y + offPtY);
						float curHeight = Heights[actX, actY];
						float nrm = (curHeight + rootAmt) / 2;
						float diff = curHeight - nrm;
						Heights[actX, actY] += diff / (step / 2);
					}
				}
			}
		}

		public int GetSeamlessPoint(int dimLen, int point) {
			if (point < 0) {
				point = dimLen + point;
			} else if (point >= dimLen) {
				point = point - dimLen;
			}

			return point;
		}

		public void AntiAlias(float threshold = 0.4f) {
			int dimX = Heights.GetLength (0);
			int dimY = Heights.GetLength (1);

			for (int x = 0; x < dimX; x++) {
				for (int y = 0; y < dimY; y++) {
					float height = Heights[x, y];
					float lastAlias = 0f;
					for (int u = -1; u <= 1; u++) {
						for (int v = -1; v <= 1; v++) {
							if (u == 0 && v == 0) { continue; }

							int actX = GetSeamlessPoint(dimX, x + u);
							int actY = GetSeamlessPoint(dimY, y + v);
							float offHeight = Heights[actX, actY];
							if (height > offHeight + threshold) {
								lastAlias = (height + offHeight) / 2;
								Heights[actX, actY] = lastAlias;
							}
						}
					}
					if (lastAlias > 0f) {
						Heights[x, y] = Heights[x, y] + lastAlias / 2;
					}
				}
			}
		}

		public void AvgPoint(int x, int y) {
			int dimX = Heights.GetLength (0);
			int dimY = Heights.GetLength (1);

			float total = Heights[x, y];
			for (int u = -1; u <= 1; u++) {
				for (int v = -1; v <= 1; v++) {
					if (u == 0 && v == 0) { continue; }

					int actX = GetSeamlessPoint(dimX, x + u);
					int actY = GetSeamlessPoint(dimY, y + v);
					total += Heights[actX, actY];
				}
			}
			Heights[x, y] = total / 9f;
		}

		public void MendSeams() {
			int dimX = Heights.GetLength (0);
			int dimY = Heights.GetLength (0);

			for (int x = dimX - 1, y = 0; y < dimY; y++) {
				Heights[x, y] = Heights[0, y];
			}

			Heights[0, 0] = 0.4f;
			Heights[0, dimY - 1] = 0.4f;
		}
	}
}

